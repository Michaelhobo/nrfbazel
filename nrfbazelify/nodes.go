package nrfbazelify

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/Michaelhobo/nrfbazel/internal/bazel"
	"gonum.org/v1/gonum/graph"
)

type Node interface {
	graph.Node
	Label() *bazel.Label
}

// LibraryNode is a node that is a single library.
type LibraryNode struct {
	id int64
	label *bazel.Label
	Srcs, Hdrs []string
	// Library nodes that have been merged into group nodes become pointer nodes.
	// Pointer nodes just point to a single group node as a dependency.
	IsPointer bool
}

func (l *LibraryNode) ID() int64 {
	return l.id
}

func (l *LibraryNode) DOTID() string {
	return l.Label().String()
}

func (l *LibraryNode) Label() *bazel.Label {
	return l.label
}

// GroupNode is a node that's a group of libraries.
type GroupNode struct {
	id int64
	label *bazel.Label
	Srcs, Hdrs []string
}

func (g *GroupNode) ID() int64 {
	return g.id
}

func (g *GroupNode) DOTID() string {
	return g.Label().String()
}

func (g *GroupNode) Label() *bazel.Label {
	return g.label
}

// Absorb merges the contents of node into the GroupNode,
// and clears the contents of the node.
func (g *GroupNode) Absorb(node Node) error {
	ownDir := g.Label().Dir()
	nodeDir := node.Label().Dir()
	if !strings.HasPrefix(nodeDir, ownDir) {
		return fmt.Errorf("%q must be a subdirectory of %q", nodeDir, ownDir)
	}
	rel, err := filepath.Rel(ownDir, nodeDir)
	if err != nil {
		return fmt.Errorf("filepath.Rel(%q, %q): %v", ownDir, nodeDir, err)
	}

	var srcs, hdrs []string
	switch n := node.(type) {
	case *GroupNode:
		srcs = append(srcs, n.Srcs...)
		hdrs = append(hdrs, n.Hdrs...)
		n.Srcs = nil
		n.Hdrs = nil
	case *LibraryNode:
		srcs = append(srcs, n.Srcs...)
		hdrs = append(hdrs, n.Hdrs...)
		n.Srcs = nil
		n.Hdrs = nil
	default:
		return fmt.Errorf("node %q not supported", node.Label())
	}

	for i := range srcs {
		srcs[i] = filepath.Join(rel, srcs[i])
	}
	for i := range hdrs {
		hdrs[i] = filepath.Join(rel, hdrs[i])
	}

	g.Srcs = append(g.Srcs, srcs...)
	g.Hdrs = append(g.Hdrs, hdrs...)
	return nil
}

// OverrideNode is a node generated by target_overrides.
// It doesn't generate a BUILD rule, and if a Node with the same label already exists,
// the OverrideNode with the same label isn't created.
type OverrideNode struct {
	id int64
	label *bazel.Label
}

func (o *OverrideNode) ID() int64 {
	return o.id
}

func (o *OverrideNode) DOTID() string {
	return o.Label().String()
}

func (o *OverrideNode) Label() *bazel.Label {
	return o.label
}