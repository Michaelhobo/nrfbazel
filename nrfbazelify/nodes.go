package nrfbazelify

import (
	"fmt"

	"github.com/Michaelhobo/nrfbazel/internal/bazel"
	"github.com/Michaelhobo/nrfbazel/internal/buildfile"
	"gonum.org/v1/gonum/graph"
)

type Node interface {
  graph.Node
  Label() *bazel.Label
}

// LibraryNode is a node that is a single library.
type LibraryNode struct {
  id int64
  label *bazel.Label
  Srcs, Hdrs []*bazel.Label
  Includes []string
  // Library nodes that have been merged into group nodes become pointer nodes.
  // Pointer nodes just point to a single group node as a dependency.
  IsPointer bool
}

func (l *LibraryNode) ID() int64 {
  return l.id
}

func (l *LibraryNode) DOTID() string {
  return l.Label().String()
}

func (l *LibraryNode) Label() *bazel.Label {
  return l.label
}

// GroupNode is a node that's a group of libraries.
type GroupNode struct {
  id int64
  label *bazel.Label
  Srcs, Hdrs []*bazel.Label
}

func (g *GroupNode) ID() int64 {
  return g.id
}

func (g *GroupNode) DOTID() string {
  return g.Label().String()
}

func (g *GroupNode) Label() *bazel.Label {
  return g.label
}

// Absorb merges the contents of node into the GroupNode,
// and clears the contents of the node.
func (g *GroupNode) Absorb(node Node) error {
  switch n := node.(type) {
  case *GroupNode:
    g.Srcs = append(g.Srcs, n.Srcs...)
    g.Hdrs = append(g.Hdrs, n.Hdrs...)
    n.Srcs = nil
    n.Hdrs = nil
  case *LibraryNode:
    g.Srcs = append(g.Srcs, n.Srcs...)
    g.Hdrs = append(g.Hdrs, n.Hdrs...)
    n.Srcs = nil
    n.Hdrs = nil
  default:
    return fmt.Errorf("node %q not supported", node.Label())
  }
  return nil
}

// OverrideNode is a node generated by target_overrides.
// It doesn't generate a BUILD rule, and if a Node with the same label already exists,
// the OverrideNode with the same label isn't created.
type OverrideNode struct {
  id int64
  label *bazel.Label
}

func (o *OverrideNode) ID() int64 {
  return o.id
}

func (o *OverrideNode) DOTID() string {
  return o.Label().String()
}

func (o *OverrideNode) Label() *bazel.Label {
  return o.label
}

// RemapNode is a node generated by remaps.
// It generates label settings used to map remap files like the sdk_config per binary.
type RemapNode struct {
  id int64
  label *bazel.Label
  LabelSetting *buildfile.LabelSetting
}

func (r *RemapNode) ID() int64 {
  return r.id
}

func (r *RemapNode) DOTID() string {
  return r.Label().String()
}

func (r *RemapNode) Label() *bazel.Label {
  return r.label
}